// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Kong.Models
{
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;

    public partial class PluginUpsert
    {
        /// <summary>
        /// Initializes a new instance of the PluginUpsert class.
        /// </summary>
        public PluginUpsert()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the PluginUpsert class.
        /// </summary>
        /// <param name="name">The name of the Plugin that’s going to be added.
        /// Currently the Plugin must be installed in every Kong instance
        /// separately.</param>
        /// <param name="config">The configuration properties for the Plugin
        /// which can be found on the plugins documentation page in the Kong
        /// Hub.</param>
        /// <param name="route">If set, the plugin will only activate when
        /// receiving requests via the specified route. Leave unset for the
        /// plugin to activate regardless of the Route being used. Defaults to
        /// null. With form-encoded, the notation is route.id=&lt;route_id&gt;.
        /// With JSON, use "route":{"id":"&lt;route_id&gt;"}.</param>
        /// <param name="service">If set, the plugin will only activate when
        /// receiving requests via one of the routes belonging to the specified
        /// Service. Leave unset for the plugin to activate regardless of the
        /// Service being matched. Defaults to null. With form-encoded, the
        /// notation is service.id=&lt;service_id&gt;. With JSON, use
        /// "service":{"id":"&lt;service_id&gt;"}.</param>
        /// <param name="consumer">If set, the plugin will activate only for
        /// requests where the specified has been authenticated. (Note that
        /// some plugins can not be restricted to consumers this way.). Leave
        /// unset for the plugin to activate regardless of the authenticated
        /// consumer. Defaults to null. With form-encoded, the notation is
        /// consumer.id=&lt;consumer_id&gt;. With JSON, use
        /// "consumer":{"id":"&lt;consumer_id&gt;"}.</param>
        /// <param name="runOn">Control on which Kong nodes this plugin will
        /// run, given a Service Mesh scenario. Accepted values are: * first,
        /// meaning “run on the first Kong node that is encountered by the
        /// request”. On an API Getaway scenario, this is the usual operation,
        /// since there is only one Kong node in between source and
        /// destination. In a sidecar-to-sidecar Service Mesh scenario, this
        /// means running the plugin only on the Kong sidecar of the outbound
        /// connection. * second, meaning “run on the second node that is
        /// encountered by the request”. This option is only relevant for
        /// sidecar-to-sidecar Service Mesh scenarios: this means running the
        /// plugin only on the Kong sidecar of the inbound connection. * all
        /// means “run on all nodes”, meaning both sidecars in a
        /// sidecar-to-sidecar scenario. This is useful for tracing/logging
        /// plugins.</param>
        /// <param name="enabled">Whether the plugin is applied.</param>
        public PluginUpsert(string name = default(string), IDictionary<string, object> config = default(IDictionary<string, object>), RoutePreview route = default(RoutePreview), ServicePreview service = default(ServicePreview), ConsumerPreview consumer = default(ConsumerPreview), string runOn = default(string), bool? enabled = default(bool?))
        {
            Name = name;
            Config = config;
            Route = route;
            Service = service;
            Consumer = consumer;
            RunOn = runOn;
            Enabled = enabled;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets the name of the Plugin that’s going to be added.
        /// Currently the Plugin must be installed in every Kong instance
        /// separately.
        /// </summary>
        [JsonProperty(PropertyName = "name")]
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the configuration properties for the Plugin which can
        /// be found on the plugins documentation page in the Kong Hub.
        /// </summary>
        [JsonProperty(PropertyName = "config")]
        public IDictionary<string, object> Config { get; set; }

        /// <summary>
        /// Gets or sets if set, the plugin will only activate when receiving
        /// requests via the specified route. Leave unset for the plugin to
        /// activate regardless of the Route being used. Defaults to null. With
        /// form-encoded, the notation is route.id=&amp;lt;route_id&amp;gt;.
        /// With JSON, use "route":{"id":"&amp;lt;route_id&amp;gt;"}.
        /// </summary>
        [JsonProperty(PropertyName = "route")]
        public RoutePreview Route { get; set; }

        /// <summary>
        /// Gets or sets if set, the plugin will only activate when receiving
        /// requests via one of the routes belonging to the specified Service.
        /// Leave unset for the plugin to activate regardless of the Service
        /// being matched. Defaults to null. With form-encoded, the notation is
        /// service.id=&amp;lt;service_id&amp;gt;. With JSON, use
        /// "service":{"id":"&amp;lt;service_id&amp;gt;"}.
        /// </summary>
        [JsonProperty(PropertyName = "service")]
        public ServicePreview Service { get; set; }

        /// <summary>
        /// Gets or sets if set, the plugin will activate only for requests
        /// where the specified has been authenticated. (Note that some plugins
        /// can not be restricted to consumers this way.). Leave unset for the
        /// plugin to activate regardless of the authenticated consumer.
        /// Defaults to null. With form-encoded, the notation is
        /// consumer.id=&amp;lt;consumer_id&amp;gt;. With JSON, use
        /// "consumer":{"id":"&amp;lt;consumer_id&amp;gt;"}.
        /// </summary>
        [JsonProperty(PropertyName = "consumer")]
        public ConsumerPreview Consumer { get; set; }

        /// <summary>
        /// Gets or sets control on which Kong nodes this plugin will run,
        /// given a Service Mesh scenario. Accepted values are: * first,
        /// meaning “run on the first Kong node that is encountered by the
        /// request”. On an API Getaway scenario, this is the usual operation,
        /// since there is only one Kong node in between source and
        /// destination. In a sidecar-to-sidecar Service Mesh scenario, this
        /// means running the plugin only on the Kong sidecar of the outbound
        /// connection. * second, meaning “run on the second node that is
        /// encountered by the request”. This option is only relevant for
        /// sidecar-to-sidecar Service Mesh scenarios: this means running the
        /// plugin only on the Kong sidecar of the inbound connection. * all
        /// means “run on all nodes”, meaning both sidecars in a
        /// sidecar-to-sidecar scenario. This is useful for tracing/logging
        /// plugins.
        /// </summary>
        [JsonProperty(PropertyName = "run_on")]
        public string RunOn { get; set; }

        /// <summary>
        /// Gets or sets whether the plugin is applied.
        /// </summary>
        [JsonProperty(PropertyName = "enabled")]
        public bool? Enabled { get; set; }

    }
}
